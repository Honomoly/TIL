#include <stdio.h>
#include <string.h>

struct car {
    char name[10];
    int year;
};

int main() {
    puts("------1------");
    // 1. 배열
    int arr1[5] = {2, 3, 5, 7, 11}; // 배열 선언
    printf("%d %d\n", arr1[0], arr1[2]); // 어딜 가나 동일한 접근법

    int arr2[2][3] = {2, 3, 5, 7, 11, 13}; // 2차원 배열 선언
    printf("%d\n", arr2[1][1]); // 똑같다

    /*
     *주의*
    C언어는 배열의 길이를 좃도 신경쓰지 않는다.
    인덱스가 배열의 범위를 벗어나도 주의 문구만 나올 뿐, 그냥 다음 주소값에 해당하는 값을 가져와 작업한다.
    그래서 이는 개발자가 알아서 주의해가며 컨트롤할 필요가 있다.
    */


    // 2. 구조체(사용자 정의 자료형)
    /*
    굳이 말하자면, 언럭키 class이다.
    서로 다른 형식의 데이터들을 한데 묶어 관리할 수 있는 형태이다.
    인스턴스마냥 생성하지만 메소드같은 것은 없다.
    */
    struct car gg = {"Genesis", 2019}; // 선언과 동시에 초기화
    struct car ss; // 구조체 선언 후 초기화는 조금 제약이 따른다
    strcpy(ss.name, "Sonata"); ss.year = 2017; // 구조체 초기화 / 문자열의 경우 string.h에서 제공하는 strcpy 함수를 이용
    printf("Model : %s, Year : %d\n", gg.name, gg.year);
    printf("Model : %s, Year : %d\n", ss.name, ss.year);

    puts("------2------");


    // 2. 포인터
    int data = 10;
    int *p; // 포인터 변수 선언 / 참조할 데이터의 타입과 동일하게 선언해야 한다
    p = &data; // 주소값을 할당
    printf("%d\n", *p); // 가리키는 값(10)이 그대로 나온다

    *p = 20; // 가리키는 곳의 값을 바꾸면 원본도 바뀜 / data = 20;와 동일한 효과이다
    printf("%d %d\n", data, *p); // 둘 다 20으로 출력


    printf("%d\n", p);
    printf("%d\n", p+1);
    /*
    주소값에 n만큼 더하면 nx4 증가한 값이 나오게 된다.
    여기서 4는 int의 타입 크기를 의미한다.
    다시 말해, 메모리에서 int가 4칸(byte)만큼 용량을 차지하고 있기 때문에 다음 데이터가 담긴 주소로 가기 위해서는
    4의 배수만큼 주소를 건너뛸 필요가 있음을 보여준다.
    */
    
    puts("------3------");
    // 위에서 정의한 배열(arr1)을 사용한다 / 사실 arr1 자체가 주소값 정보를 가지고 있다
    printf("%d\n", arr1); // 쌩으로 출력하면 실제로 주소만 나온다 / 타입은 int *
    printf("%d\n", *arr1); // 이래야 가장 첫 배열값이 나오게 된다 / arr1[0] = 2 와 동일하다
    printf("%d\n", *(arr1+2)); // 주소값을 증가시키면 해당 배열값이 나온다 / arr1[2] = 5 와 동일하다

    puts("------4------");
    // 위에서 정의한 2차원 배열(arr2)을 사용한다
    printf("%d\n", arr2); // 타입은 int (*)[3]
    // 2차원이기 때문에 주소값이 2중으로 할당되어 있으므로, *을 두 번 써야 첫 값에 도달한다
    printf("%d\n", **arr2); // arr2[0][0] = 2 와 동일하다
    // 첫 덧셈에서는 행 방향으로 주소를 이동하고, 두 번째 덧셈에서는 열 방향으로 주소를 이동하는 효과를 보여준다
    printf("%d\n", *(*(arr2+1)+1)); // arr2[1][1] = 11 와 동일하다

    return 0;
}

